NIP-04
======

加密私信
--------

`终稿` `可选` `作者:arcbtc`

一种类型为 `4` 的特殊事件，意为“加密私信”。它应具有以下属性：

**`content`** **必须**是以 base64 编码的，使用 aes-256-cbc 加密的任何用户想要写的字符串，使用由接收者的公钥和发送者的私钥生成的共享密码进行加密；后接以 base64 编码的初始向量，就好似名为“iv”的查询字符串参数。格式如下：`"content": "<加密文本>?iv=<初始向量>"`。

**`tags`** **必须**包含一个识别消息接收者的条目（以便中继可以自然地将此事件转发给他们），形式为 `["p", "<公钥，十六进制字符串>"]`。

**`tags`** **可以**包含一个识别对话中的上一条消息或我们明确回复的消息的条目（以便可以进行有上下文的，更有组织的对话），形式为 `["e", "<事件 id>"]`。

**注意**：在 [libsecp256k1](https://github.com/bitcoin-core/secp256k1) ECDH 实现中，默认情况下，密码是共享点的 SHA256 哈希（X 和 Y 坐标）。在 Nostr 中，只有共享点的 X 坐标被用作密码，且**不会**被哈希。如果使用 libsecp256k1，必须将复制 X 坐标的自定义函数作为 `hashfp` 参数传递给 `secp256k1_ecdh`。请参阅[此处](https://github.com/bitcoin-core/secp256k1/blob/master/src/modules/ecdh/main_impl.h#L29)。

在 JavaScript 中生成此类事件的代码示例：

```js
import crypto from 'crypto'
import * as secp from '@noble/secp256k1'

let sharedPoint = secp.getSharedSecret(ourPrivateKey, '02' + theirPublicKey)
let sharedX = sharedPoint.slice(1, 33)

let iv = crypto.randomFillSync(new Uint8Array(16))
var cipher = crypto.createCipheriv(
  'aes-256-cbc',
  Buffer.from(sharedX),
  iv
)
let encryptedMessage = cipher.update(text, 'utf8', 'base64')
encryptedMessage += cipher.final('base64')
let ivBase64 = Buffer.from(iv.buffer).toString('base64')

let event = {
  pubkey: ourPubKey,
  created_at: Math.floor(Date.now() / 1000),
  kind: 4,
  tags: [['p', theirPublicKey]],
  content: encryptedMessage + '?iv=' + ivBase64
}
```

## 安全警告

此标准远未达到端间加密通信的最新技术水平，同时元数据会在事件中泄露，因此除非使用 `AUTH` 来限制谁可以获取你的 `kind:4` 事件，否则不应用于你真正需要保密的任何事情。

## 客户端实现警告

客户端*不应*从 `.content` 中搜索并替换引用的公钥或贴文。如果像处理常规贴文一样处理（其中 `@npub...` 被替换为带有 `["p", "..."]` 标签的 `#[0]`）则标签会泄露，而且提及的用户会在他们的收件箱中收到消息。
