NIP-05
======

将 Nostr 公钥映射到基于 DNS 的互联网标识符
------------------------------------------

`终稿` `可选` `作者:fiatjaf` `作者:mikedilger`

在类型为 `0`（`metadata`）的事件中，可以指定键为 `"nip05"`，其值为[互联网标识符](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1)（类似电子邮件的地址）。尽管上面有一个非常宽松的“互联网标识符”规范的链接，但 NIP-05 假定 `<local-part>` 部分将限制为字符 `a-z0-9-_.`，且不区分大小写。

当看到该映射，客户端将标识符分割为 `<local-part>` 和 `<domain>`，并使用这些值向 `https://<domain>/.well-known/nostr.json?name=<local-part>` 发出 GET 请求。

结果应该是一个 JSON 文档对象，其中有一个键为 `"names"`，然后应该是一个名称到十六进制格式公钥的映射。如果给定 `<name>` 的公钥与 `元数据` 事件中的 `pubkey` 匹配，客户端则得出结论，即给定的 pubkey 确实可以由其标识符引用。

### 示例

如果客户端看到像这样的事件：

```json
{
  "pubkey": "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9",
  "kind": 0,
  "content": "{\"name\": \"bob\", \"nip05\": \"bob@example.com\"}"
  ...
}
```

它将向 `https://example.com/.well-known/nostr.json?name=bob` 发送 GET 请求，并得到一个看起来像这样的响应

```json
{
  "names": {
    "bob": "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9"
  }
}
```

或者带有**可选**的 `"relays"` 属性:

```json
{
  "names": {
    "bob": "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9"
  },
  "relays": {
    "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9": [ "wss://relay.example.com", "wss://relay2.example.com" ]
  }
}
```

如果公钥与 `"names"` 中给出的公钥匹配（如上例），则表示关联正确，`"nip05"` 标识符有效并可以显示。

可选的 `"relays"` 属性可能包含一个对象，其键为公钥，值为中继 URL 数组。当存在时，可以帮助客户端了解特定用户可能在哪些中继中找到。基于查询字符串动态提供 `/.well-known/nostr.json` 文件的 Web 服务器也**应该**在可用时在同一响应中为他们伺服的任何名称提供中继数据。

## 从 NIP-05 标识符找到用户

客户端可以实现支持从 _互联网标识符_ 找到用户的公钥，流程与上述相同，但是方向相反：首先，客户端获取 _well-known_ URL，从那里获取用户的公钥，然后尝试获取该用户的类型 `0` 事件，并检查是否有匹配的 `"nip05"`。

## 注意

### 客户端必须始终关注公钥，而不是 NIP-05 地址

例如，如果在发现 `bob@bob.com` 具有公钥 `abc...def` 后，用户点击一个按钮来关注该个人资料，客户端必须保留对 `abc...def` 的主要引用，而不是 `bob@bob.com`。如果出于任何原因，地址 `https://bob.com/.well-known/nostr.json?name=bob` 在将来的任何时候开始返回公钥 `1d2...e3f`，客户端不应在用户的关注个人资料列表中替换 `abc...def`（但是它应停止为该用户显示“bob@bob.com”，因为那将成为一个无效的 `"nip05"` 属性）。

### 公钥必须以十六进制格式返回

公钥必须以十六进制格式返回。NIP-19 `npub` 格式的密钥仅用于在客户端 UI 中显示，不用于此 NIP。

### 用户发现的实现建议

客户端也可以使用此功能让用户搜索其他个人资料。如果客户端有搜索框或类似的东西，用户可能能够在那里输入“bob@example.com”，客户端会识别出来并进行适当的查询以获取公钥，并将其建议给用户。

### 仅显示域名作为标识符

客户端可以将标识符 `_@domain` 视为“根”标识符，并选择仅将其显示为 `<domain>`。例如，如果 Bob 拥有 `bob.com`，他可能不希望像 `bob@bob.com` 这样的标识符，因为那是多余的。相反，Bob 可以使用标识符 `_@bob.com`，并期望 Nostr 客户端将其仅显示和处理为 `bob.com`。

### `/.well-known/nostr.json?name=<local-part>` 格式的原因

通过将 `<local-part>` 添加为查询字符串而不是路径的一部分，协议既可以支持按需生成 JSON 的动态服务器，也可以支持其中可能包含多个名称的 JSON 文件的静态服务器。

### 允许 JavaScript 应用程序访问

JavaScript Nostr 应用程序可能受到浏览器 [CORS][] 策略的限制，阻止它们访问用户域上的 `/.well-known/nostr.json`。当 CORS 阻止 JS 加载资源时，JS 程序将其视为与资源不存在的网络故障相同，因此纯 JS 应用程序无法确定故障是由 CORS 问题引起的。看到请求 `/.well-known/nostr.json` 文件的网络故障的 JS Nostr 应用程序可能希望向用户推荐检查他们服务器的 CORS 策略，例如：

```bash
$ curl -sI https://example.com/.well-known/nostr.json?name=bob | grep -i ^Access-Control
Access-Control-Allow-Origin: *
```

用户提供他们的 `/.well-known/nostr.json` 时应带有 `Access-Control-Allow-Origin: *` 的 HTTP 头，以确保它可以被运行在现代浏览器中的纯 JS 应用程序用以验证。

[CORS]: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS

### 安全限制

`/.well-known/nostr.json` 端点**不能**返回任何 HTTP 重定向。

请求方**必须**忽略 `/.well-known/nostr.json` 端点给出的任何 HTTP 重定向。
