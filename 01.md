NIP-01
======

基本协议流程描述
----------------

`草案` `强制性` `作者:fiatjaf` `作者:distbit` `作者:scsibug` `作者:kukks` `作者:jb55` `作者:semisol` `作者:cameri` `作者:Giszmo`

本 NIP 定义了每个人都应该实现的基本协议。新的 NIP 可以向这里描述的结构和流程添加新的可选（或强制性）字段、消息和特性。

## 事件和签名

每个用户都有一个密钥对。签名、公钥和编码都按照[ secp256k1 曲线的 Schnorr 签名标准](https://bips.xyz/340)进行。

唯一存在的对象类型是 `event`，它在网络中的格式如下：

```json
{
  "id": <32 字节长的对序列化事件数据的 sha256，小写十六进制编码>,
  "pubkey": <事件创建者公钥的 32 字节长的小写十六进制编码>,
  "created_at": <unix 时间戳（以秒为单位）>,
  "kind": <0 到 65535 之间的整数>,
  "tags": [
    [<任意字符串>...],
    ...
  ],
  "content": <任意字符串>,
  "sig": <64 字节长的对序列化事件数据 sha256 哈希，即 "id" 字段，的签名，小写十六进制编码>
}
```

为了获得 `event.id`，我们对序列化的事件进行 `sha256`。序列化是在以下结构的 UTF-8 JSON 序列化字符串上完成的（不含空格或换行符）：

```json
[
  0,
  <pubkey, 公钥，以小写十六进制字符串表示>,
  <created_at, 创建时间，以数字表示>,
  <kind, 类型，以数字表示>,
  <tags, 标签，以非空字符串数组的数组表示>,
  <content, 内容，以字符串表示>
]
```

### 标签

每个标签都是一个长度任意的字符串数组，但有一些约定俗成的规则。请看下面的例子：

```json
{
  ...,
  "tags": [
    ["e", "5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36", "wss://nostr.example.com"],
    ["p", "f7234bd4c1394dda46d09f35bd384dd30cc552ad5541990f98844fb06676e9ca"],
    ["a", "30023:f7234bd4c1394dda46d09f35bd384dd30cc552ad5541990f98844fb06676e9ca:abcd", "wss://nostr.example.com"],
    ["alt", "reply"],
    ...
  ],
  ...
}
```

标签数组的第一个元素被称为标签的 _名称_ 或 _键_，第二个元素被称为标签的 _值_。因此，我们可以安全地说，上面的事件有个 `e` 标签被设置为 `"5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"`，一个 `alt` 标签被设置为 `"reply"` 等。第二个元素之后的所有元素都没有惯例名称。

此 NIP 定义了 3 个标准标签，可在所有事件类型中使用，具有相同的含义。它们如下：

- `e` 标签，用于引用事件：`["e", <另一个事件的 32 字节小写十六进制 id>, <推荐的中继 URL，可选>]`
- `p` 标签，用于引用另一个用户：`["p", <32 字节小写十六进制公钥>, <推荐的中继 URL，可选>]`
- `a` 标签，用于引用（可能是参数化的）可替换事件
  - 对于参数化的可替换事件：`["a", <kind 整数>:<32 字节小写十六进制公钥>:<d 标签值>, <推荐的中继 URL，可选>]`
  - 对于非参数化的可替换事件：`["a", <kind 整数>:<32 字节小写十六进制公钥>:, <推荐的中继 URL，可选>]`

作为惯例，所有单字母（仅限英文字母：a-z、A-Z）键的标签都应由中继进行索引，以便可以查询或订阅引用了事件 `"5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"` 的事件，方法是使用 `{"#e": "5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"}` 过滤器。

### 类型

类型指定客户端应如何解释每个事件的含义和事件的其他字段（例如，`"r"` 标签在类型 1 的事件中可能具有某个含义，在类型 10002 的事件中可能具有完全不同的含义）。每个 NIP 可以定义一组未在其他地方定义的类型的含义。此 NIP 定义了两种基本类型：

- `0`：**元数据**：`content` 设置为描述创建事件的用户的字符串化 JSON 对象 `{name：<用户名>，about：<字符串>，picture：<URL，字符串>}`。中继可以在获得相同 pubkey 的新事件后删除旧事件。
- `1`：**文本注释**：`content` 设置为（用户想说的任何内容）的**纯文本**内容。不应使用必须解析的内容，例如 Markdown 和 HTML。客户端也不应解析内容。

还有一种类型范围的约定，允许更轻松的实验和中继实现的灵活性：

- 对于类型 `n`，使得 `1000 <= n <10000`，事件是**常规**的，这意味着它们都应该由中继存储。
- 对于类型 `n`，使得 `10000 <= n <20000 || n == 0 || n == 3`，事件是**可替换**的，这意味着对于每个 `pubkey` 和 `kind` 的组合，只有最新的事件**必须**由中继存储，旧版本**可以**被丢弃。
- 对于类型 `n`，使得 `20000 <= n <30000`，事件是**短暂的**，这意味着不应期望它们被中继存储。
- 对于类型 `n`，使得 `30000 <= n <40000`，事件是**参数化可替换**的，这意味着对于每个 `pubkey`，`kind` 和 `d` 标记的第一个值的组合，只有最新的事件**必须**由中继存储，旧版本**可以**被丢弃。

在具有相同时间戳的可替换事件的情况下，应保留具有最低 ID（按字典顺序排列的第一个）的事件，并丢弃其他事件。

当回答针对可替换事件的 `REQ` 消息（例如 `{"kinds"：[0]，"authors"：[<十六进制键>]}`）时，即使中继存储了多个版本，它也**应该**仅返回最新版本。

这些只是约定，中继实现可能会有所不同。

## 客户端和中继之间的通信

中继公开了一个 websocket 端点，客户端可以连接到该端点。客户端**应该**对每个中继打开一个 websocket 连接，并将其用于所有订阅。中继**可以**限制来自特定 IP / 客户端等的连接数。

### WebSocket 状态代码的含义

- 当中继使用状态代码 `4000` 关闭 websocket 时，这意味着客户端不应再尝试连接。

### 从客户端到中继：发送事件和创建订阅

客户端可以发送 3 种类型的消息，这些消息必须是 JSON 数组，格式如下：

  * `["EVENT", <前述定义的事件 JSON>]`，用于发布事件。
  * `["REQ", <subscription_id>, <过滤器 JSON>...]`，用于请求事件并订阅更新。
  * `["CLOSE", <subscription_id>]`，用于停止以前的订阅。

`<subscription_id>` 是最大长度为 64 个字符的任意非空字符串，应用于表示订阅。中继应该独立地管理每个 WebSocket 连接的 `<subscription_id>`；即使 `<subscription_id>` 是相同的字符串，对于不同的连接，它们也应该被视为不同的订阅。

`<filters>` 是一个 JSON 对象，用于确定将在该订阅中发送哪些事件，它可以具有以下属性：

```json
{
  "ids": <事件 id 列表>,
  "authors": <小写公钥列表，事件的公钥必须是其中之一>,
  "kinds": <类型编号列表>,
  "#<单个字母（a-zA-Z）>": <标签值列表，对于 #e - 事件 id 列表，对于 #p - 事件公钥列表等>,
  "since": <整数 unix 时间戳（以秒为单位），事件必须比此新才能通过>,
  "until": <整数 unix 时间戳（以秒为单位），事件必须比此旧才能通过>,
  "limit": <中继在初始查询中应返回的最大事件数>
}
```

在收到 `REQ` 消息后，中继应查询其内部数据库并返回与过滤器匹配的事件，然后存储该过滤器并再次将其发送到同一 websocket，直到 websocket 关闭。即接收到带有同一个 `<subscription_id>` 的 `CLOSE` 事件或新的 `REQ` 消息，在后一种情况下，中继必须覆盖先前的订阅。

包含列表（`ids`，`authors`，`kinds` 和 `#e` 等标签过滤器）的过滤器属性是具有一个或多个值的 JSON 数组。至少一个数组的值必须与事件中的相关字段匹配，才能将条件视为匹配。对于标量事件属性，例如 `authors` 和 `kind`，事件中的属性必须包含在过滤器列表中。对于标签属性（例如 `#e`），事件可能具有多个值，事件和过滤器条件值必须至少有一个共同项。

`ids`，`authors`，`#e` 和 `#p` 过滤器列表**必须**包含精确的 64 个字符的小写十六进制值。

`since` 和 `until` 属性可用于指定订阅中返回的事件的时间范围。如果过滤器包括 `since` 属性，则将 `created_at` 大于或等于 `since` 的事件视为匹配过滤器。`until` 属性类似，只是 `created_at` 必须小于或等于 `until`。简而言之，如果 `since <= created_at <= until` 成立，则事件与过滤器匹配。

对于事件通过过滤器的所有条件，它必须匹配，即多个条件被解释为 `&&` 条件。

`REQ` 消息可能包含多个过滤器。在这种情况下，与任何过滤器匹配的事件都将被返回，即多个过滤器将被解释为 `||` 条件。

过滤器的 `limit` 属性仅对初始查询有效，并且在此后**必须**被忽略。当存在 `limit: n` 时，假定在初始查询中返回的事件将是按 `created_at` 排序的最后 `n` 个事件。返回的事件少于 `limit` 指定的事件是安全的，但是期望中继不会返回比请求的事件（更多）的事件，以便客户端不会因数据而不堪重负。

### 从中继到客户端：发送事件和通知

中继可以发送 4 种类型的消息，这些消息也必须是 JSON 数组，格式如下：

  * `["EVENT", <subscription_id>, <前述定义的事件 JSON>]`，用于发送客户端所请求的事件。
  * `["OK", <event_id>, <true|false>, <message>]`，用于指示接受或拒绝 `EVENT` 消息。
  * `["EOSE", <subscription_id>]`，用于指示 _存储事件的结束_ 和实时接收到的事件的开始。
  * `["NOTICE", <message>]`，用于向客户端发送人类可读的错误消息或其他内容。

此 NIP 没有定义 `NOTICE` 消息应如何发送或处理。

- `EVENT` 消息**必须**只能使用与客户端先前初始化所用的订阅 ID 发送（使用上面的 `REQ` 消息）。
- `OK` 消息**必须**作为对从客户端接收到的 `EVENT` 消息的响应发送，当中继接受事件时，第 3 个参数必须设置为 `true`，否则必须设置为 `false`。当第 3 个参数为 `true` 时，第 4 个参数**可以**为空，否则**必须**是一个包含机器可读的单词前缀后跟者 `:` 和人类可读消息的字符串。标准化的机器可读前缀为：`duplicate`，`pow`，`blocked`，`rate-limited`，`invalid` 以及当没有相符条件时使用的 `error`。一些例子：

  * `["OK", "b1a649ebe8...", true, ""]`
  * `["OK", "b1a649ebe8...", true, "pow: difficulty 25>=24"]`
  * `["OK", "b1a649ebe8...", true, "duplicate: already have this event"]`
  * `["OK", "b1a649ebe8...", false, "blocked: you are banned from posting here"]`
  * `["OK", "b1a649ebe8...", false, "blocked: please register your pubkey at https://my-expensive-relay.example.com"]`
  * `["OK", "b1a649ebe8...", false, "rate-limited: slow down there chief"]`
  * `["OK", "b1a649ebe8...", false, "invalid: event creation date is too far off from the current time. Is your system clock in sync?"]`
  * `["OK", "b1a649ebe8...", false, "pow: difficulty 26 is less than 30"]`
  * `["OK", "b1a649ebe8...", false, "error: could not connect to the database"]`
