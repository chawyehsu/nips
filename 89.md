NIP-89
======

应用处理程序推荐
----------------

`草案` `可选` `作者:pablof7z`

本 NIP 描述了 `kind:31989` 和 `kind:31990`：一种发现可以处理未知事件类型的应用程序的方法。

## 原理

Nostr 的可发现性和透明的事件交互是其最有趣/新颖的机制之一。
本 NIP 为客户端提供了一种简单的方式，可以发现处理特定类型事件的应用程序，以确保顺畅的跨客户端和跨类型交互。

### 参与方

此工作流程有三个参与者：

* 处理特定事件类型的应用程序（注意，应用程序不一定需要是一个独立的实体，它可能是与用户 A 相同的公钥）
    * 发布 `kind:31990`，详细告知应用程序应如何导向它
* 用户 A，推荐处理特定事件类型的应用程序
    * 发布 `kind:31989`
* 用户 B，寻找处理特定事件类型的应用程序的推荐
    * 查询 `kind:31989`，并根据结果查询 `kind:31990`

# 事件

## 推荐事件

```json
{
    "kind": 31989,
    "pubkey": <recommender-user-pubkey>,
    "tags": [
        [ "d", <supported-event-kind> ],
        [ "a", "31990:app1-pubkey:<d-identifier>", "wss://relay1", "ios" ],
        [ "a", "31990:app2-pubkey:<d-identifier>", "wss://relay2", "web" ]
    ]
}
```

在 `kind:31989` 中，`d` 标签是此事件推荐的支持的事件类型。

同一个 `kind:31989` 可以出现多个 `a` 标签。

标签的第 2 个值**应该**是一个中继提示。
标签的第 3 个值**应该**是可能适用此推荐的平台。

## 处理程序信息

```json
{
    "kind": 31990,
    "pubkey": <pubkey>,
    "content": "<optional-kind:0-style-metadata>",
    "tags": [
        [ "d", <random-id> ],
        [ "k", <supported-event-kind> ],
        [ "web", "https://..../a/<bech32>", "nevent" ],
        [ "web", "https://..../p/<bech32>", "nprofile" ],
        [ "web", "https://..../e/<bech32>" ],
        [ "ios", ".../<bech32>" ]
    ]
}
```

* `content` 是一个可选的类似 `metadata` 的字符串化 JSON 对象，如 NIP-01 所述。当创建 `kind:31990` 的公钥不是应用程序时，这很有用。如果 `content` 为空，应使用公钥的 `kind:0` 来显示应用程序信息（例如，名称，图片，网页，LUD16 等）。

* `k` 标签的值是 `kind:31990` 支持的事件类型。
使用 `k` 标签（而不是在 NIP-33 的 `d` 标签上的类型）可提供：
    * 如果应用程序支持多种事件类型并且它们的处理程序 URL 是相同的，那么同一个事件中可以存在多个 `k` 标签。
    * 同一个公钥可以有多个事件，其中不同的应用程序处理相同的事件类型。

* URL 中的 `bech32` **必须**由客户端替换为应用程序应加载的 NIP-19 编码的实体。

应用程序可能会注册多个标签，作为数组的第 2 个值遵循 NIP-19 的命名法。

数组中没有第 2 个值的标签**应该**被视为任何 NIP-19 实体的通用处理程序，除非有其他标签处理。

# 用户流程

使用以非 `kind:1` 为主的 nostr app 的用户 A 可以选择宣布/推荐某种类型处理程序应用程序。

当用户 B 看到一个未知的事件类型，例如，在以社交为主 nostr 客户端中，客户端将允许用户 B 与未知类型的事件进行交互（例如，点击它）。

客户端**可能**会查询用户和用户的处理程序。

# 示例

## 用户 A 推荐 `kind:31337` 处理程序

用户 A 可能是 Zapstr 的用户，Zapstr 是一个以 `kind:31337` 为主的（跟踪）客户端。使用 Zapstr，用户 A 发布了一个事件，推荐 Zapstr 作为 `kind:31337` 的处理程序。

```json
{
    "kind": 31989,
    "tags": [
        [ "d", "31337" ],
        [ "a", "31990:1743058db7078661b94aaf4286429d97ee5257d14a86d6bfa54cb0482b876fb0:abcd", <relay-url>, "web" ]
    ]
}
```

## 用户 B 与 `kind:31337` 处理程序交互

用户 B 可能在他们的时间线上看到一个引用 `kind:31337` 事件的事件（例如，一个 `kind:1` 标记一个 `kind:31337`）。

用户 B 的客户端不知道如何处理 `kind:31337`，可能会使用其 `alt` 标签（如 NIP-31 所述）显示事件。当用户点击事件时，应用程序查询此 `kind` 的处理程序：

`["REQ", <id>, '[{ "kinds": [31989], "#d": ["31337"], 'authors': [<user>, <users-contact-list>] }]']`

关注用户 A 的用户 B 看到这个 `kind:31989` 事件，并获取`a` 标记的带有应用程序和处理程序信息的事件。

用户 B 的客户端看到应用程序的 `kind:31990` 中包含将用户重定向到相关 URL 的信息，并在 URL 中替换所需的实体。

## 绕过 `kind:31989` 的替代查询

另外，用户可能选择直接查询 `kind:31990` 以获取事件类型。客户端在执行此操作时**应该**小心，并使用防垃圾信息机制，以避免将用户引导到恶意处理程序。

`["REQ", <id>, '[{ "kinds": [31990], "#k": [<desired-event-kind>], 'authors': [...] }]']`
