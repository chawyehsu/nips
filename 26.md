NIP-26
======

委托事件签名
------------

`草案` `可选` `作者:markharding` `作者:minds`

此 NIP 定义了如何委托事件，使它们可以由其他密钥对签名。

这个提案的另一个应用是在与客户端交互时抽象出使用“根”密钥对的过程。例如，用户可以为他们希望使用的每个客户端生成新的密钥对，并授权这些密钥对代表他们的根公钥生成事件，其中根密钥对存储在冷存储中。

#### 引入“delegation”标签

此 NIP 引入了一个新标签：`delegation`，其格式如下：

```json
[
  "delegation",
  <委托者的公钥>,
  <条件查询字符串>,
  <委托令牌：委托字符串的 sha256 哈希的 64 字节 Schnorr 签名>
]
```

##### 委托令牌

**委托令牌**应该是以下字符串的 sha256 哈希的 64 字节 Schnorr 签名：

```
nostr:delegation:<发布者的公钥（受托者）>:<条件查询字符串>
```

##### 条件查询字符串

上述查询字符串支持以下字段和运算符：

*字段*：
1. `kind`
  -  *运算符*：
    -  `=${KIND_NUMBER}` - 受托者只能签署此类别的事件
2. `created_at`
  -  *运算符*：
    -  `<${TIMESTAMP}` - 受托者只能签署在指定时间戳**之前**创建的事件
    -  `>${TIMESTAMP}` - 受托者只能签署在指定时间戳**之后**创建的事件

为了创建一个单一的条件，必须使用一个支持的字段和运算符。在一个查询字符串中可以使用多个条件，包括在同一个字段上。条件必须用 `&` 组合。

例如，以下条件字符串是有效的：

- `kind=1&created_at<1675721813`
- `kind=0&kind=1&created_at>1675721813`
- `kind=1&created_at>1674777689&created_at<1675721813`

对于绝大多数的使用情况，建议：
1. 查询字符串应包括一个反映当前时间的 `created_at` **之后**条件，以防止受托者代表委托者发布历史记录。
2. 查询字符串应包括一个不为空且不是在极远的未来的 `created_at` **之前**条件。如果委托不限制时间范围，它们将暴露与简单地使用根密钥进行身份验证相类似的安全风险。

#### 示例

```
# 委托者:
privkey: ee35e8bb71131c02c1d7e73231daa48e9953d329a4b701f7133c8f46dd21139c
pubkey:  8e0d3d3eb2881ec137a11debe736a9086715a8c8beeeda615780064d68bc25dd

# 受托者:
privkey: 777e4f60b4aa87937e13acc84f7abcc3c93cc035cb4c1e9f7a9086dd78fffce1
pubkey:  477318cfb5427b9cfc66a9fa376150c1ddbc62115ae27cef72417eb959691396
```

从现在开始，根据当前时间戳 `1674834236`，将在接下来的 30 天内授予受托者（477318cf）发布贴文的授权的委托字符串。

```json
nostr:delegation:477318cfb5427b9cfc66a9fa376150c1ddbc62115ae27cef72417eb959691396:kind=1&created_at>1674834236&created_at<1677426236
```

然后，委托者（8e0d3d3e）对上述委托字符串的 SHA256 哈希进行签名，得到的结果就是委托令牌：

```
6f44d7fe4f1c09f3954640fb58bd12bae8bb8ff4120853c4693106c82e920e2b898f1f9ba9bd65449a987c39c0423426ab7b53910c0c6abfb41b30bc16e5f524
```

现在，受托者（477318cf）可以代表委托者（8e0d3d3e）构造一个事件。然后，受托者使用自己的私钥对事件进行签名并发布。

```json
{
  "id": "e93c6095c3db1c31d15ac771f8fc5fb672f6e52cd25505099f62cd055523224f",
  "pubkey": "477318cfb5427b9cfc66a9fa376150c1ddbc62115ae27cef72417eb959691396",
  "created_at": 1677426298,
  "kind": 1,
  "tags": [
    [
      "delegation",
      "8e0d3d3eb2881ec137a11debe736a9086715a8c8beeeda615780064d68bc25dd",
      "kind=1&created_at>1674834236&created_at<1677426236",
      "6f44d7fe4f1c09f3954640fb58bd12bae8bb8ff4120853c4693106c82e920e2b898f1f9ba9bd65449a987c39c0423426ab7b53910c0c6abfb41b30bc16e5f524"
    ]
  ],
  "content": "Hello, world!",
  "sig": "633db60e2e7082c13a47a6b19d663d45b2a2ebdeaf0b4c35ef83be2738030c54fc7fd56d139652937cdca875ee61b51904a1d0d0588a6acd6168d7be2909d693"
}
```

如果满足条件（在此示例中为 `kind=1`，`created_at>1674834236` 和 `created_at<1677426236`），并且在验证委托令牌后，发现这些条件与原始委托字符串中的条件未发生变化，那么该事件应被视为有效的委托。

客户端应显示委托的笔记，就像它是由委托者（8e0d3d3e）直接发布的一样。

#### 中继和客户端支持

中继应该通过查询 `pubkey` 和委托标签 `[1]` 的值来回答诸如 `["REQ", "", {"authors": ["A"]}]` 的请求。

中继**应该**允许委托者（8e0d3d3e）删除受托者（477318cf）发布的事件。
