NIP-13
======

工作证明
--------

`草案` `可选` `作者:jb55` `作者:cameri`

此 NIP 定义了一种为 nostr 贴文生成和解释工作证明的方法。工作证明（PoW）是一种将计算工作的证明添加到贴文的方法。这是所有中继和客户端都可以用少量代码普遍验证的不记名证明。这个证明可以作为阻止垃圾邮件的手段。

`difficulty` 被定义为 `NIP-01` id 中前导 0 的位数。例如，id 为 `000000000e9d97a1ab09fc381030b346cdd7a142ad57e6df0b46dc9bef6c7e2d` 的难度为 `36`，有 `36` 个前导 0 位。

`002f...` 在二进制中是 `0000 0000 0010 1111...`，有 10 个前导 0。不要忘记算上 <= `7` 的十六进制数字的前导 0。

挖矿
----

```json
{"content": "It's just me mining my own business", "tags": [["nonce", "1", "21"]]}
```

挖矿时，`nonce` 标签的第二个条目被更新，然后重新计算 id（参见 [NIP-01](./01.md)）。如果 id 具有所需数量的前导 0 位，那么贴文已被挖掘。建议在此过程中也更新 `created_at`。

`nonce` 标签的第三个条目**应该**包含目标难度。这允许客户端防止大量垃圾邮件发送者针对较低难度的情况下幸运地匹配到更高的难度。例如，如果你需要 40 位来回复你的线程，并看到一个承诺的目标为 30，即使贴文有 40 位难度，你也可以安全地拒绝它。如果没有承诺的目标难度，你就不能拒绝它。承诺一个目标难度是所有诚实的矿工都应该可以接受的，如果缺少难度承诺，客户端**可能**会拒绝匹配目标难度的贴文。

贴文挖矿示例
------------

```json
{
  "id": "000006d8c378af1779d2feebc7603a125d99eca0ccf1085959b307f64e5dd358",
  "pubkey": "a48380f4cfcc1ad5378294fcac36439770f9c878dd880ffa94bb74ea54a6f243",
  "created_at": 1651794653,
  "kind": 1,
  "tags": [
    [
      "nonce",
      "776797",
      "21"
    ]
  ],
  "content": "It's just me mining my own business",
  "sig": "284622fc0a3f4f1303455d5175f7ba962a3300d136085b9566801bc2e0699de0c7e31e44c81fb40ad9049173742e904713c3594a1da0fc5d2382a25c11aba977"
}
```

验证
----

这是一些 C 代码参考，用于计算 nostr 事件 id 中的难度（也就是前导 0 的位数）：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int countLeadingZeroes(const char *hex) {
    int count = 0;

    for (int i = 0; i < strlen(hex); i++) {
        int nibble = (int)strtol((char[]){hex[i], '\0'}, NULL, 16);
        if (nibble == 0) {
            count += 4;
        } else {
            count += __builtin_clz(nibble) - 28;
            break;
        }
    }

    return count;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <hex_string>\n", argv[0]);
        return 1;
    }

    const char *hex_string = argv[1];
    int result = countLeadingZeroes(hex_string);
    printf("Leading zeroes in hex string %s: %d\n", hex_string, result);

    return 0;
}
```

这是一些 JavaScript 代码，用于做同样的事情：

```javascript
// hex should be a hexadecimal string (with no 0x prefix)
function countLeadingZeroes(hex) {
  let count = 0;

  for (let i = 0; i < hex.length; i++) {
    const nibble = parseInt(hex[i], 16);
    if (nibble === 0) {
      count += 4;
    } else {
      count += Math.clz32(nibble) - 28;
      break;
    }
  }

  return count;
}
```

从中继查询获取 PoW 贴文
-----------------------

如果中继允许在前缀上进行搜索，你可以使用这种方式来过滤出带有确定难度的贴文：

```
$ echo '["REQ", "subid", {"ids": ["000000000"]}]'  | websocat wss://some-relay.com | jq -c '.[2]'
{"id":"000000000121637feeb68a06c8fa7abd25774bdedfa9b6ef648386fb3b70c387", ...}
```

委托工作证明
------------

由于 `NIP-01` 贴文 id 并未承诺任何签名，因此可以将 PoW 外包给 PoW 提供商，可能需要支付一定的费用。这为客户端提供了一种方式，可以将他们的消息发送到需要 PoW 的中继，而无需自己做任何工作，这对于像移动电话这样的能源受限设备非常有用。
